// =============================================================================
// Console Messages
// =============================================================================

module.exports = function(lessOptions) {
  const path = require('path'),
        chalk = lessOptions.rootRequire('chalk'),
        shown = lessOptions.consoleLogs === undefined ? true : lessOptions.consoleLogs,
        prefix = chalk.bold.green('LESS Framework: ') + chalk.gray("(" + lessOptions.id + ")");
  return {
    message: function(...msgs) {
      if (!shown) return; 
      msgs.unshift(prefix);
      console.log.apply(console, msgs);
    },
    required: function(...msgs) {
      msgs.unshift(prefix);
      console.log.apply(console, msgs);
    },
    error: function(...msgs) {
      msgs.unshift(chalk.red('(Error) '));
      this.required.apply(this, msgs);
    },
    warning: function(...msgs) {
      if (!shown) return;
      msgs.unshift(chalk.yellow('(Warning) '));
      this.message.apply(this, msgs);
    },
    list: function(title, array) {
      if (!shown) return;
      if (!title) {
        console.log(" - " +  array.join("\n - "));
      } else {
        this.message.call(this, title, "\n - " +  array.join("\n - "));
      }
    },
    listOrdered: function(title, array) {
      if (!shown) return;
      var list = array.reduce((acc, current, index) => {
        var item = "  " + (index + 1) + ". " + current.toString();
        return acc + item + (index !== array.length - 1 ? "\n" : "");
      }, "");
      if (!title) {
        console.log(list);
      } else {
        this.message.call(this, title, "\n" + list);
      }
    },
    dev: function(...msgs) {
      if (!lessOptions.consoleLogsDev) return; // Do nothing
      msgs.unshift(chalk.magenta("(dev debug)"));
      msgs.unshift(prefix);
      console.log.apply(console, msgs);
    },
    memory: function(scriptProcess, ...msgs) {
      if (!lessOptions.consoleLogsDev) return; // Do nothing

      const used = scriptProcess.memoryUsage(),
            details = [];

      for (let key in used) {
        details.push(`\n - ${key} ${Math.round(used[key] / 1024 / 1024 * 100) / 100} MB`);
      }
      this.dev.apply(this, msgs.concat(details));
    },
    time: function(label = prefix) {
      if (!shown) return;
      console.time(label);
    },
    timeEnd: function(label = prefix) {
      if (!shown) return;
      console.timeEnd(label);
    }
  };
};