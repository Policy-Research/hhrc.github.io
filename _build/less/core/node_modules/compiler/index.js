// =============================================================================
// Less Framework Compiler
// =============================================================================
// 
// Verison:         1.0.0
// 
// Note:            - Does not do the WYSIWYG stylesheet


const path = require('path');
const fs = require('fs');
const less = require('less');
const chalk = require('chalk');
const chokidar = require('chokidar');
const merge = Object.assign;
const LessFramework = require('../less-framework.js');

const logHeader = chalk.yellow('LESS Framework Compiler: ');

const defaults = {
  filename: '../../init/stylesheet.less',
  globalVars: {
   "wysiwyg-stylesheet": false
  },
  plugins: [ 
    require('less-plugin-lists') 
  ],
  sourceMap: {
    sourceMapFileInline: false,
    outputSourceFiles: true
  }
};
const frameworkDefaults = {
  baseDir: '',
  rootRequire: require,
  id: "styles",
  filename: "../css/styles.css",
  consoleLogs: true,
  consoleLogsDev: false,
  formatLogs: true,
  formatLogsSimplePaths: true,
  // pathCore: pathCore,
  // pathSite: pathSite,
  pathJavascript: "src/_library/js/less-includes.js",
};

function log(msg) {
  console.log(logHeader + msg);
}
function logError(msg) {
  console.error(logHeader +  chalk.red(msg));
}

less.logger.addListener({
  info:   log,
  debug:  logError,
  warn:   logError,
  error:  logError
});

// Get the main entry point
class LessFrameworkCompiler {
  constructor(options, optionsLess, optionsFw) {
    this.optionsLess = merge({}, defaults, optionsLess);
    this.options = options;
    this.watcher = null;
    this.framework = null;
    this.watchPaths = null;
    this.framework = LessFramework(
      merge({}, frameworkDefaults, optionsFw)
    );
    this.pathsGood = this.framework.checkPaths();
    if (!this.pathsGood) {
      this.pathError();
    }
  }
  compile() {
    if (!this.pathsGood) {
      this.pathError();
      return; 
    }
    this.runFramework();
    this.render();
  }
  pathError() {
    logError('Paths Error');
  }
  runFramework() {
    
    const lessPaths = this.framework.pathList;
    if (this.framework.checkPaths()) {
      this.framework.modulesInit();
      // Add paths for less compiler
      this.optionsLess.paths = lessPaths.resolve;
      this.optionsLess.globalVars.pathSite = `"${ lessPaths.site }"`;
      this.optionsLess.globalVars.pathCore = `"${ lessPaths.core }"`;
      this.optionsLess.filename = this.framework.pathList.stylesheet;
    }
  }
  render() {
    fs.readFile(this.optionsLess.filename, (error, file) => {
      if (error) {
        logError('Error reading main stylesheet.less');
        console.error(error);
      } else {
        
        less.render(file.toString(), this.optionsLess)
          .then((output) => {
            fs.writeFileSync(this.options.outputPath, output.css);
            fs.writeFileSync(this.options.outputPath + '.map', output.map);
          })
          .catch((error) => { 
            logError('Error in Less Compiler');
            console.error(error);
          });
      }
    });
  }
  watch() {
    this.compile();
    const ignored = this.framework.pathList.watchIgnore;

    ignored.push('**/node_modules/**');
    this.watcher = chokidar.watch(this.framework.pathList.watchGlob, {
      ignored: ignored
    });

    const handleChange = (path) =>  {
      log('(watch) Reacting to file / director change. ' + path);
      this.compile();
    };

    // this.watcher.on('add', handleChange);
    this.watcher.on('change', handleChange);
    // this.watcher.on('unlink', handleChange);
    // this.watcher.on('addDir', handleChange);
    // this.watcher.on('unlinkDir', handleChange);
  }
}

exports.compiler = LessFrameworkCompiler;

